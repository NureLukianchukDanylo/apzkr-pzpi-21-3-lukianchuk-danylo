Міністерство освіти і науки України
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА

з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для управління подіями в торгово-розважальних центрах

Студент гр. ПЗПІ-21-3 	__________________ Лук’янчук Д. О.
(підпис)

Керівник роботи 		__________________ доц. Лещинська І.О.
(підпис)
Роботу захищено «__»_________2024 р.
з оцінкою _________________________

Комісія: 				__________________ доц. Лещинська І.О.
(підпис)
__________________ доц. Лещинський В.О.
(підпис)
__________________ ст.викл. Сокорчук І.П.
(підпис)
Харків
2024 р.
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук                           Кафедра програмної інженерії     
Спеціальність 121 – Інженерія програмного забезпечення                                       
Курс                   3                   Семестр                                  6                                       
Навчальна дисципліна Архітектура програмного забезпечення                              

ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ

                                            Лук’янчуку Данилу Олеговичу                                           
1. Тема роботи: «Програмна система для управління подіями в торгово-розважальних центрах» – EventSuite
2. Термін узгодження завдання курсової роботи «19»    лютого     2024 р.
3. Термін здачі студентом закінченої роботи «15»    червня     2024 р.
4. Вихідні дані до проекту (роботи): У програмній системі передбачити: авторизацію та створення нових акаунтів для відвідувачів подій, організаторів подій, власників ТРЦ та адміністраторів; редагування, додавання та видалення даних щодо подій, ресурсів, місць проведення подій, квитків та реєстрації на події, «розумних» браслетів, бронювання місць проведення подій; отримання статистики проведених подій щодо кількості відвідувачів та використаних ресурсів, витрачених коштів та доходу від квитків; створення резервних копій бази даних та управління користувачами і ролями у системі; вибір перекладу інтерфейсу українською або англійською мовами; отримання доступу до подій за «розумними» браслетами; отримання поточного місцезнаходження власника браслету. Використовувати ОС Windows 10 або 11, систему управління базами даних Microsoft SQL Server 2019, редактор коду Visual Studio Code, середовище розробки Microsoft Visual Studio 2022, мови програмування TypeScript та C#, а також фреймворки ASP.NET Core 8.0 для серверної частини і Angular 16 для клієнтської частини
5. Зміст пояснювальної записки (перелік питань, що належить розробити)
Вступ, аналіз предметної області, постановка задачі, проектування програмного проекту, структура бази даних, кодування програмного проекту, опис розробленої програмної системи, висновки, перелік посилань, додатки                                                                                                                          
6. Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень)
Діаграми розгортання, діаграми прецедентів, діаграми пакетів, діаграма компонентів, діаграма взаємодії, діаграма діяльності, ER-модель даних, файлова структура серверної та клієнтської частин проекту, схема ІоТ пристрою, інтерфейс сторінки редагування подій, інтерфейс сторінки управління ресурсами 
КАЛЕНДАРНИЙ ПЛАН

№	Назва етапів курсової роботи	Термін виконання
етапів роботи	Примітка
1	Функціональна специфікація
програмного проекту	29.02.2024	виконано
2	Проектування програмного
проекту	08.03.2024	виконано
3	Кодування програмного проекту	13.05.2024	виконано
4	Оформлення пояснювальної
записки	31.05.2024	виконано
5	Захист курсової роботи	11.06.2024	виконано


Дата видачі завдання «19»       лютого       2024 р.

Керівник 					______________ доц. Лещинська І.О.
(підпис)

Завдання прийняв до виконання
ст.гр. ПЗПІ-21-3					 _____________ Лук’янчук Д. О.
(підпис)
 
РЕФЕРАТ

Пояснювальна записка до курсової роботи: 81 с., 20 рис., 3 табл., 4 додатки, 6 джерел.
БРОНЮВАННЯ МАЙДАНЧИКІВ, ВІДВІДУВАЧ, ВЛАСНИК ТРЦ, КВИТОК, ЛОКАЛІЗАЦІЯ, МІСЦЕ ПРОВЕДЕННЯ, ОРГАНІЗАТОР, ПОДІЯ, РЕЗЕРВНА КОПІЯ БАЗИ ДАНИХ, РЕСУРС, ТОРГОВО-РОЗВАЖАЛЬНИЙ ЦЕНТР, УПРАВЛІННЯ КОРИСТУВАЧАМИ.
Об’єктом дослідження цієї роботи виступає сфера організації різноманітних подій, зокрема у торгово-розважальних центрах. Загалом цей процес є доволі  складним [1], бо задля успішної роботи потрібно брати до уваги багато факторів: бронювання майданчиків, управління необхідними ресурсами для проведення подій, покупка та повернення квитків, проведення подій тощо. 
Тож метою роботи є розробка програмної системи для управління подіями в торгово-розважальних центрах. Ця платформа допоможе організаторам подій із легкістю орендувати майданчики та відповідні ресурси для проведення подій, власникам місць проведення – публікувати про свої майданчики інформацію та знаходити на них орендарів, а відвідувачам подій – отримувати інформацію про події та купувати на них квитки. Крім того, у системі передбачена автоматизація доступу до подій за допомогою «розумних» браслетів, які можуть бути надані відвідувачам подій.
Методами розробки є платформа .NET 8, фреймворк ASP.NET Core 8.0, ORM Entity Framework Core 8.0, система авторизації та аутентифікації  ASP.NET Core Identity, СУБД Microsoft SQL Server 2019, що разом утворюють серверну частину проекту. Для створення клієнтської частини було обрано фреймворк Angular 16. Робота ІоТ пристрою базується на використанні мікроконтролера ESP32.
У результаті було створено систему, що дозволяє організовувати події, управляти необхідними для них ресурсами, бронювати майданчики, купувати квитки, а також надавати доступ до подій за допомогою браслетів. Ця програмна система складається із 3 компонентів: серверної частини, клієнтської частини та ІоТ пристрою.
ЗМІСТ

Вступ	8
1 Бізнес-вимоги	9
1.1 Передумови	9
1.2 Бізнес-можливості	9
1.3 Бізнес-цілі та критерії успіху	10
1.4 Потреби клієнтів та ринку	11
1.5 Бізнес-ризики	12
2 Концепція рішення	14
2.1 Окреслення концепції	14
2.2 Головна функціональність	14
2.3 Припущення та залежності	15
3 Рамки та обмеження	16
3.1 Рамки первинного випуску	16
3.2 Рамки наступних випусків	17
3.3 Обмеження та винятки	18
4 Бізнес-контекст	19
4.1 Профілі зацікавлених сторін	19
4.2 Пріоритети проекту	20
4.3 Робоче середовище	21
5 Серверна частина	22
5.1 Опис прийнятих інженерних рішень	22
5.2 Діаграми	24
5.3 Специфікація REST	27
5.4 Опис частин програмного коду	32
5.4.1 Аутентифікація	32
5.4.2 Обробник помилок	33
5.4.3 Методи розширення	34
6 ІоТ пристрій	36
6.1 Опис прийнятих інженерних рішень	36
6.2 Пояснення програмного коду	37
6.3 Діаграми	39
7 Клієнтська частина	42
7.1 Опис прийнятих інженерних рішень	42
7.2 Пояснення частин програмного коду	44
7.2.1 Авторизація	44
7.2.2 Локалізація	45
7.3 Діаграми	47
Висновки	50
Перелік джерел посилання	51
Додаток А Програмний код серверної частини	52
Додаток Б Програмний код ІоТ пристрою	68
Додаток В Програмний код клієнтської частини	73
Додаток Г Результат перевірки на плагіат	81





ВСТУП

У сучасному світі торгово-розважальні центри (ТРЦ) стали невід'ємною частиною міського життя. Вони не тільки забезпечують місце для покупок і розваг, але й слугують платформою для проведення різноманітних заходів: концертів, виставок, фестивалів, рекламних акцій тощо. З огляду на зростаючий попит на якісний відпочинок і розваги, ефективне управління подіями в ТРЦ набуває все більшої актуальності.
Забезпечення успішного проведення заходів вимагає координації багатьох аспектів: від планування і організації до контролю за виконанням і аналізу результатів. Для цього потрібні сучасні інструменти, які дозволяють автоматизувати й оптимізувати процеси управління подіями. Важливим завданням є створення програмної системи, яка б відповідала потребам як власникам ТРЦ, так і організаторів заходів, забезпечуючи зручний інтерфейс і широкий функціонал.
Метою курсової роботи є розробка програмної системи для управління подіями в торгово-розважальних центрах. Ця система повинна включати в себе інструменти для планування заходів, управління ресурсами, бронювання майданчиків, покупки та повернення квитків, а також засоби для збору даних та аналізу ефективності проведених заходів. Розробка такої системи сприятиме підвищенню ефективності роботи торгово-розважальних центрів, покращенню якості обслуговування відвідувачів та збільшенню прибутковості закладів.
У рамках цієї роботи буде проведено аналіз існуючих рішень на ринку, визначено основні вимоги до програмної системи, розроблено архітектуру та реалізовано відповідну програмну систему, що надасть повноцінний функціонал для організації та управління подіями. Крім того, буде здійснено тестування розробленої системи. 
Таким чином, дана курсова робота має на меті внести вагомий внесок у розвиток інформаційних технологій у сфері управління подіями та сприяти підвищенню конкурентоспроможності ТРЦ на ринку послуг.
1	БІЗНЕС-ВИМОГИ
1.1 Передумови

У сучасному світі в торгово-розважальних центрах виникає необхідність в ефективному управлінні подіями, оскільки вони стають ключовим елементом привертання клієнтів та створення позитивного враження від відвідування. Управління цими подіями може бути складною та дуже часозатратною задачею через їх різноманітність та великий обсяг роботи. Традиційні методи планування і координації можуть бути обмеженими, не забезпечуючи оптимального використання ресурсів та не дозволяючи ефективно взаємодіяти з аудиторією.
Відповідно до цього, розробка програмної системи управління подіями для ТРЦ, такої як «EventSuite», стає важливою. Ця система має на меті вирішити недоліки традиційного підходу, надаючи інструменти для зручного планування, моніторингу та аналізу подій. «EventSuite» прагне стати інтегрованою платформою, що спрощує процес планування та проведення подій в ТРЦ, підвищуючи їхню ефективність та конкурентоспроможність.

1.2 Бізнес-можливості

На ринку існують кілька аналогічних систем, таких як «EventPlanner» та «EventManager». «EventPlanner», хоч і надає базовий функціонал для організації подій, має обмеження в аналізі даних та інтеграції з іншими системами. Ця платформа дозволяє користувачам створювати події, керувати графіком та додавати основні деталі, такі як дати та часи проведення, місце, список учасників тощо. Однак «EventPlanner» не надає розширеного функціоналу для аналізу даних щодо учасників подій або їхнього зв'язку з різними аспектами організації.
«EventManager», з іншого боку, дозволяє користувачам створювати та керувати подіями, забезпечуючи розширений набір інструментів для організаторів. Ця система зазвичай включає функції планування подій, керування бюджетом, реєстрацію учасників, створення розкладів подій, взаємодію з учасниками через різноманітні комунікаційні канали та інше. Однак «EventManager» також має свої обмеження, зокрема в області аналітики та інтеграції з іншими системами для оптимізації процесів організації подій.
Переваги «EventSuite» полягають у здатності оптимізувати процес управління подіями за допомогою інтелектуальних алгоритмів, що дозволяє підвищити ефективність та забезпечити більш якісну організацію подій у торгово-розважальних центрах. Крім того, «EventSuite» має потенціал для інтеграції з іншими системами, такими як системи продажу квитків та системи контролю доступу, що розширює його функціонал та забезпечує більш повне управління подіями.
Модель монетизації «EventSuite» має декілька можливих напрямків:
1. Підписка для організаторів подій: Організатори подій можуть платити за користування платформою «EventSuite» та її функціоналом для планування, організації та аналізу подій.
2. Аналітичні послуги: Додатково, система може надавати платні послуги з аналізу даних та звітності, що дозволяє організаторам подій отримати більш детальний інсайт щодо ефективності їхніх заходів та удосконалити стратегії проведення подій.
3. Комісійні від угод: «EventSuite» може отримувати комісійні від угод, укладених через платформу, таких як продаж квитків або партнерських угод із спонсорами.
4. Партнерські відносини: Крім того, можлива співпраця з іншими компаніями та постачальниками послуг, що дозволить «EventSuite» розширити свій функціонал та надати більше можливостей для організаторів подій.

1.3 Бізнес-цілі та критерії успіху

Для системи «EventSuite» були виділені наступні бізнес-цілі:
BO-1: Зниження витрат на організацію подій у торгово-розважальних центрах на 15% протягом першого року використання «EventSuite».
BO-2: Зниження часу на підготовку та планування подій в торгово-розважальних центрах на 25% до кінця першого року використання «EventSuite».
BO-3: Збільшення кількості подій, які вдається організувати у торгово-розважальних центрах на 20% протягом перших шести місяців використання системи.
BO-4: Поліпшення системи зворотного зв'язку та швидкого реагування на запити користувачів з метою зменшення часу відповіді на 35% протягом першого року експлуатації.
Також були визначені наступні критерії успіху:
SC-1: Реєстрація не менше ніж 50 торгово-розважальних центрів для використання системи протягом перших 6 місяців після випуску.
SC-2: Підвищення рівня задоволення клієнтів на 30% після першого року використання «EventSuite», виміряне за допомогою опитування користувачів.
SC-3: Збільшення конверсії учасників подій у покупців на 25% протягом першого року використання системи.

1.4 Потреби клієнтів та ринку

Система «EventSuite» відповідає на низку важливих потреб клієнтів та ринку:
1. Організатори подій шукають зручний та ефективний інструмент для планування, координації та виконання різноманітних заходів. «EventSuite» надає їм можливість централізовано керувати всіма аспектами події, включаючи розклад, реєстрацію гостей, розподіл ресурсів та взаємодію з учасниками.
2. Клієнти торгово-розважальних центрів очікують засобів, що допоможуть їм підвищити залучення та зберегти відвідувачів. «EventSuite» надає інструменти для персоналізації та взаємодії з аудиторією, включаючи сповіщення, програми лояльності та опитування задоволеності.
3. Власники торгово-розважальних центрів шукають систему, яка допоможе їм ефективно розподіляти ресурси та забезпечувати безперебійну роботу. «EventSuite» дозволяє автоматизувати процеси бронювання приміщень, керування персоналом та інші аспекти управління ресурсами.
4. Різні учасники ринку, включаючи організаторів подій та власників центрів, очікують від системи можливості збільшення прибутковості та оптимізації витрат.
Система «EventSuite»  розроблена з урахуванням цих потреб, надаючи ринку інтегрований інструмент для ефективного управління подіями.

1.5 Бізнес-ризики

У реалізації проекту «EventSuite» можуть виникнути наступні ризики:
1. Конкуренція на ринку: Існує ризик великої конкуренції зі сторони існуючих та нових учасників на ринку програмного забезпечення для управління подіями. Для уникнення цього ризику необхідно продовжувати вдосконалювати та розширювати функціональні можливості «EventSuite», надавати якісну технічну підтримку та активно просувати продукт на ринку.
2. Технічні проблеми: Існує ризик технічних проблем, таких як системні збої, безпекові порушення або неправильна робота програмного забезпечення. Для зменшення цього ризику слід регулярно проводити аудит безпеки, вдосконалювати процеси тестування та підтримувати високий рівень стабільності та надійності системи.
3. Недооцінка потреб ринку: Розробка функціональності, яка не відповідає потребам клієнтів, може призвести до низької популярності продукту на ринку. Для уникнення цього ризику важливо проводити регулярні дослідження ринку, залучати потенційних користувачів до процесу розробки та активно збирати їх фідбек для вдосконалення продукту.
4. Затримки у впровадженні: Невдале планування та керування проектом може спричинити затримки у впровадженні «EventSuite». Для уникнення цього ризику варто ретельно планувати кожен етап розробки, враховуючи можливі труднощі та ризики, а також вчасно реагувати на будь-які зміни та проблеми, що виникають під час проектування та реалізації системи.
Для управління цими ризиками, «EventSuite» повинна вести систематичний моніторинг, розробляти плани управління кризами, регулярно оновлювати технічну інфраструктуру та дотримуватися найкращих практик у сфері безпеки даних.
2 КОНЦЕПЦІЯ РІШЕННЯ
2.1 Окреслення концепції

Програмна система «EventSuite» призначена для ефективного управління та координації подій в торгово-розважальних центрах. Метою її розробки є створення інтегрованої платформи, яка допоможе організаторам подій та власникам центрів ефективно планувати, проводити та відстежувати різноманітні заходи. «EventSuite» надає зручні інструменти для керування подіями, реєстрацією учасників, взаємодії з гостями та управління ресурсами.
Ця система покликана стати ключовим інструментом для підвищення ефективності та залучення аудиторії на події в торгово-розважальних центрах. ««EventSuite»» стане інноваційним рішенням, яке забезпечить безперебійну організацію заходів, покращить взаємодію з клієнтами та сприятиме розвитку бізнесу клієнтів. 
Загалом «EventSuite» є програмним забезпеченням, що допоможе досягнути успіху у світі організації подій.

2.2 Головна функціональність

MF-1: Управління подіями (додавання, видалення, редагування подій);
MF-2: Реєстрація та покупка квитків для участі у події;
MF-3: Реєстрація та авторизація для користувачів на платформі;
MF-4: Створення та зміна графіку подій;
MF-5: Перегляд та аналіз даних для проведених подій;
MF-6: Бронювання майданчиків;
MF-7: Управління ресурсами (обладнання, персонал) для проведення подій;
MF-8: Звітність щодо проведених подій; 
MF-9: Сповіщення для учасників події про її наближення;
MF-10: Опитування для учасників подій;
MF-11: Розширена аналітика щодо подій;
MF-12: Контроль доступу на події із використанням «розумних» браслетів;
MF-13: Можливість обрати український або англійський варіант інтерфейсу на платформі;
MF-14: Можливість створення резервних копій бази даних для адміністраторів;
MF-15: Можливість керувати користувачами системи для адміністраторів.

2.3 Припущення та залежності

Припущення:
1. Система «EventSuite» зможе залучити значну кількість клієнтів, незважаючи на конкуренцію з боку існуючих систем.
2. «EventSuite» почне приносити дохід за перші 6-9 місяців.
3. Користувачі мають доступ до Інтернету для взаємодії з системою «EventSuite». 
4. Забезпечення доступ доу важливих даних, таких як графіки подій, контактна інформація гостей та необхідні ресурси, для ефективного використання функціоналу системи.
Залежності:
1. Успішне впровадження «EventSuite» залежить від можливості інтеграції з існуючими системами управління клієнтами або системами продажу квитків.
2. Наявність технічної підтримки для вирішення можливих проблем та відмов.
3. Відповідність системи «EventSuite» змінам у законодавстві щодо обробки та захисту даних.
4. Наявність необхідних ресурсів, таких як сервери та обладнання для роботи системи.
3 РАМКИ ТА ОБМЕЖЕННЯ
3.1 Рамки первинного випуску

Серверна частина програмної системи надаватиме користувачам наступний функціонал:
1. Створення облікових записів для користувачів (власники ТРЦ, організатори подій, учасники подій).
2. Система авторизації та автентифікації для безпечного доступу до системи.
3. Управління подіями (додавання, видалення, редагування подій);
4. Реєстрація та покупка квитків для участі у події;
5. Створення та зміна графіку подій;
6. Перегляд та аналіз даних для проведених подій;
7. Управління ресурсами (обладнання, персонал) та бронювання майданчиків для проведення подій;
8. Звітність щодо проведених подій;
9. Контроль доступу на події із використанням «розумних» браслетів;
10. Управління користувачами для адміністраторів.
11. Можливість обрати український або англійський варіант інтерфейсу.
12. Можливість створення резервних копій бази даних для адміністраторів.
Клієнтська частина надаватиме можливість використовувати функціонал серверної частини і відповідатиме за наступне:
1. Веб-інтерфейс для власників ТРЦ та організаторів подій для створення та редагування подій, а також графіків їх проведення.
2. Інтерфейс реєстрації на подію або покупки квитка.
3. Зручний та простий інтерфейс для реєстрації та авторизації користувачів.
4. Відображення аналітичних даних щодо проведених подій.
5. Зручний спосіб обрати англійський або український переклад інтерфейсу.
6. Відображення необхідних ресурсів для проведення подій (майданчик, обладнання, персонал).
У якості IoT буде використовуватися «розумний» браслет із таким функціоналом:
1. Відстеження місця перебування відвідувачів події.
2. Контроль доступу до різних зон проведення події.

3.2 Рамки наступних випусків

Наступні випуски системи «EventSuite» будуть спрямовані на постійне покращення та розширення функціональності, щоб задовольнити зростаючі потреби користувачів та реагувати на ринкові вимоги. Планується реалізація таких функціональних можливостей у майбутніх випусках:
1. Додаткова аналітика та звітність: Додаткові засоби для аналізу та візуалізації даних щодо ефективності рекламних кампаній. Створення наступного рівня інтелектуальних звітів.
2. Проведення опитувань: Проведення опитувань серед відвідувачів подій для покращення їх планування організаторами у майбутньому.
3. Інтеграції з соціальними медіа: Розширення можливостей спілкування та взаємодії через платформи соціальних медіа для залучення більшої аудиторії та підвищення зацікавленості до подій.
4. Розширений інтерфейс адміністратора: Вдосконалення інтерфейсу для адміністраторів з метою полегшення управління програмною системою.




3.3 Обмеження та винятки

У новому продукті «EventSuite» передбачаються обмеження та винятки:
1. Обмежена підтримка старого обладнання: Не планується повна сумісність із застарілим обладнанням у торгово-розважальних центрах.
2. Підтримка системи у інших сферах: Можливість використання системи управління подіями буде доступна лише для ТРЦ або схожих за сферою закладах.
3. Частковий офлайн-режим: Більшість функцій системи будуть доступні лише за підключення до Інтернету (за виключенням функцій перегляду аналітики проведених подій та створення звітів на їх основі). 
4 БІЗНЕС-КОНТЕКСТ
4.1 Профілі зацікавлених сторін 

Таблиця 4.1 – Профілі зацікавлених сторін
Зацікавлені сторони	Основна цінність	Ставлення	Основні інтереси	Обмеження
Власники ТРЦ	Оптимізація використання простору, збільшення доходу від подій	Очікують покращення управління подіями, збільшення популярності ТРЦ	Ефективне планування та виконання подій, залучення більшої аудиторії	Бюджетні обмеження, технічні обмеження інтеграції з наявною інфраструктурою
Організатори подій	Ефективне планування та проведення подій	Очікують зручного та інтуїтивно зрозумілого інструментарію для організації подій	Легке створення та керування різноманітними подіями, отримання звітності	Технічні обмеження, нестабільність під час впровадження
Учасники подій	Зручний доступ до інформації, різноманітний та цікавий контент	Очікують інтерактивності та персоналізованого контенту	Перегляд та участь у різноманітних подіях, отримання інформації	Залежність від функціональності системи, доступу до технологій
Адміністратори ТРЦ	Ефективне керування та моніторинг системи	Очікують зручного та ефективного інтерфейсу управління	Адміністрування та підтримка системи, моніторинг використання ресурсів	Потреба в навчанні та підтримці, необхідність адаптації до нової системи
4.2 Пріоритети проекту

Таблиця 4.2 – Пріоритети проекту
Показник	Виконання (етапи)	Обмеження (граничні значення)	Ступінь свободи (діапазон можливостей)
Графік	Випуск MVP відбувається до 15.05	Випуск MVP відбувається не пізніше, ніж через 5 днів після дедлайну	MVP може вийти в реліз до 10.05
Функціонал	Для версії 1.0 має бути готово 85% функціоналу.	Завершеність функціоналу не є більш ніж на 15% нижчою за очікувану.	Включення 70-80% високопріоритетних функцій у версію 1.0.
Якість	Система має проходити 100% тестів, бути стабільною та без критичних помилок.	Ресурси та час на тестування	Можлива відсутність доступу до системи через проведення технічного обслуговування.
Персонал	Розмір команди: 1 розробник.	Розробляється 1 людиною.	Достатній рівень навичок для створення продукту.
Ціна	Бюджет 20 тисяч доларів. На версію 1.0 витратити 75% бюджету, на 1.1 – інші 25%.	Для версії 1.0 витрати не перевищують 4%, для 1.1 – 5%.	Перевищення бюджету до 9% прийнятне без розгляду керівництвом.
4.3 Робоче середовище

Серверна частина проекту буде писатися на платформі .NET 8 із використанням мови програмування C#. Для створення API буде використовуватися фреймворк ASP.NET Core 8.0. У якості СУБД виступатиме Microsoft SQL Server 2019. Для зв’язку API із базою даних використовуватиметься Entity Framework Core 8.0. Також для автентифікації та авторизації користувачів буде використано ASP.NET Core Identity [2]. Клієнтська частина буде розроблена на базі фреймворку Angular 16, де використовується мова програмування TypeScript. Також під час розробки буде використано Docker для контейнеризації та розгортання проекту. Розробка IoT пристрою [3] буде відбуватися на базі мікроконтролера ESP32 за допомогою симулятора Wokwi на мові програмування С++. Зокрема буде використано бібліотеки «WiFi.h», яка буде використана для підключення до IoT пристрою по WiFi-мережі, та «WebServer.h», що запускатиме вебсервер для оброблення HTTP-запитів.
Вимоги щодо доступності, надійності, продуктивності та цілісності будуть визначені окремо для кожного компонента системи, з урахуванням вимог зацікавлених сторін та стандартів галузі. Розробка та тестування будуть здійснені з метою забезпечення високої якості та надійності продукту в робочому середовищі.
5 СЕРВЕРНА ЧАСТИНА
5.1 Опис прийнятих інженерних рішень
	
Серверна частина проекту розроблена на мові програмування С# за допомогою фреймворку ASP.NET Core 8. У якості СУБД використовується Microsoft SQL Server. Також варто відзначити, що для зв’язку API із базою даних використовується Entity Framework Core 8.0 [4]. Крім того, для автентифікації та авторизації було застосовано ASP.NET Core Identity.
	Серверна частина програмної системи має монолітну багаторівневу архітектуру, що включає у себе рівні: представлення, бізнес-логіки, доступу до даних та сервісів. Для цього було створено 4 окремих проекти в IDE:
	1) EventSuite.API є початковою точкою, що запускає застосунок та відповідає за контролери, конфігурацію JWT та мапінгів, реєстрацію сервісів (рис. 5.1);

 
Рисунок 5.1 – Файловий вигляд проекту EventSuite.API

	2) EventSuite.Core містить моделі для бази даних, Enums, відповідні DTO та налаштування мапінгу з моделі в DTO та назад (рис. 5.2);
 
Рисунок 5.2 – Структура проекту EventSuite.Core

	3) EventSuite.DAL відповідає за доступ до даних через репозиторії та наповнення бази даних тестовими даними (рис. 5.3);
 
Рисунок 5.3 – Структура проекту EventSuite.DAL
	4) EventSuite.BLL містить сервіси, що відповідають за бізнес-логіку проекту застосунку (рис. 5.4).

 
Рисунок 5.4 – Структура проекту EventSuite.BLL

5.2 Діаграми

	Для проектування бази даних було створено ER-модель даних (рис. 5.5). На ній зображено 10 сутностей: Event, Venue, Resource, Registration, Reservation, Mall, EventResource, Location, Ticket, User. На діаграмі наявні 11 зв’язків один-до-багатьох для наступних сутностей: Mall та Venue, Location та Mall, Venue та Reservation, Event та Reservation, User та Event, User та Registration, Event та Registration,  Event та EventResource, Resource та EventResource, Registration та Ticket. Також варто відмітити, що на діаграмі немає зв’язків багато-до-багатьох, що у базі даних мали б вигляд додаткових проміжних таблиць із зв’язками до відповідних сутностей.
 
Рисунок 5.5 – ER-модель даних програмної системи для управління подіями в ТРЦ «EventSuite»

	Також було зроблено діаграму розгортання (рис. 5.6) для програмної системи. Ця діаграма складається із 5 елементів: серверу, бази даних, веб-застосунку, мобільного застосунку та IoT пристрою («розумний» браслет).

 
Рисунок 5.6 – Діаграма розгортання програмної системи для управління подіями в ТРЦ «EventSuite»
	Діаграму прецедентів (Use Case Diagram) було складено для розуміння функціоналу користувачів у системі (рис. 5.7). У системі є 4 актори: власник ТРЦ, організатор подій, відвідувач подій та адміністратор. Слід відмітити, що власник ТРЦ та організатор подій обидва можуть мати доступ до функціоналу відвідувача подій, але в іншому мають доступ тільки до відповідного їх ролям функціоналу.

 
Рисунок 5.7 – Діаграма прецедентів програмної системи для управління подіями в ТРЦ «EventSuite»

	Діаграму пакетів (Package Diagram) було зроблено для демонстрації різноманітних шарів архітектури програмної системи (рис. 5.8). Діаграма показує залежності поміж пакетами та як вони використовують одне одного для виконання своїх задач. На ній зображені 9 пакетів: Event, Venue, Resource, Registration, Reservation, Mall, Location, Ticket, User.
 
Рисунок 5.8 – Діаграма пакетів програмної системи для управління подіями в ТРЦ «EventSuite»
	
5.3 Специфікація REST

	Надалі розглянемо специфікацію REST (табл. 5.1).
	Таблиця 5.1 – Специфікація REST
Посилання	Метод	Опис методу
/api/Auth/login	POST	Авторизація
/api/Auth/register	POST	Реєстрація із роллю «User»
/api/Auth/refresh	POST	Отримання нового «access» токену


Продовження таблиці 5.1
/api/Auth/register-admin	POST	Реєстрація користувачів з іншими ролями адміном
/api/Auth/revoke	POST	Відкликання «refresh» токену
/api/Event/events	GET	Отримати всі події
/api/Event/events/{userId}	GET	Отримати всі створені події для користувача
/api/Event/event/{id}	GET	Отримати подію за id
/api/Event/event/{id}	DELETE	Видалити подію за id
/api/Event/event/{id}	PUT	Оновити подію за id
/api/Event/event	POST	Створити нову подію
/api/Event/finished-events/{userId}	GET	Отримати статистику проведених подій для користувача
/api/Venue/venues	GET	Отримати всі місця проведення
/api/Venue/venues/{mallId}	GET	Отримати всі місця проведення за id ТРЦ
/api/Venue/venue/{id}	GET	Отримати місце проведення за id
/api/Venue/venue/{id}	DELETE	Видалити місце проведення за id
/api/Venue/venue/{id}	PUT	Оновити місце проведення за id
/api/Venue/venue	POST	Додати нову місце проведення
/api/Mall/malls	GET	Отримати всі ТРЦ системи

Продовження таблиці 5.1
/api/Mall/malls/{locationId}	GET	Отримати всі ТРЦ системи за місцем розташування
/api/Mall/mall/{id}	GET	Отримати ТРЦ системи за id
/api/Mall/mall/{id}	DELETE	Видалити ТРЦ за id
/api/Mall/mall/{id}	PUT	Оновити ТРЦ за id
/api/Mall/mall	POST	Додати новий ТРЦ до системи
/api/Registration/registrations	GET	Отримати реєстрації користувачів на події
/api/Registration/user-registrations/{userId}	GET	Отримати всі реєстрації користувача на події
/api/Registration/registration/ {id}	GET	Отримати реєстрацію на подію за id
/api/Registration/registration/ {id}	DELETE	Видалити реєстрацію на подію за id
/api/Registration/registration /{id}	PUT	Оновити реєстрацію на подію за id
/api/Registration/registration	POST	Створити нову реєстрацію на подію
/api/Registration/registrations/{eventId}	GET	Отримати всі реєстрації на подію
/api/Location/locations	GET	Отримати всі локації
/api/Location/location/{id}	GET	Отримати локацію за id
/api/Location/location/{id}	DELETE	Видалити локацію за id
/api/Location/location/{id}	PUT	Оновити локацію за id
/api/Location/location	POST	Створити нову локацію
Продовження таблиці 5.1
/api/Resource/resources	GET	Отримати всі ресурси для подій
/api/Resource/resource/{id}	GET	Отримати ресурс для подій за id
/api/Resource/resource/{id}	DELETE	Видалити ресурс для подій за id
/api/Resource/resource/{id}	PUT	Оновити ресурс для подій за id
/api/Resource/resource	POST	Додати новий ресурс для подій
/api/Reservation/reservations	GET	Отримати всі бронювання місць проведення
/api/Reservation/reservations/{eventId}	GET	Отримати всі бронювання місць проведення для події
/api/Reservation/reservation/ {id}	GET	Отримати бронювання місця проведення за id
/api/Reservation/reservation/ {id}	DELETE	Видалити бронювання місця проведення за id
/api/Reservation/reservation/ {id}	PUT	Оновити бронювання місця проведення за id
/api/Reservation/reservation	POST	Створити нове бронювання місця проведення
/api/Ticket/tickets	GET	Отримати всі квитки на події в системі
/api/Ticket/ticket/{id}	GET	Отримати квиток на подію за id
Кінець таблиці 5.1
/api/Ticket/tickets/ {registrationId}	GET	Отримати всі квитки для реєстрації на подію за id
/api/Ticket/ticket/{id}	DELETE	Видалити квиток на подію за id
/api/Ticket/ticket/{id}	PUT	Оновити квиток за id
/api/Ticket/ticket	POST	Купити квиток на подію
/api/EventResource/eventResources	GET	Отримати всі ресурси задіяні у події
/api/EventResource/eventResource/{id}	GET	Отримати ресурси задіяний у події за id
/api/EventResource/eventResources/{eventId}	GET	Отримати всі ресурси задіяні у події за id події
/api/EventResource/eventResource/{id}	DELETE	Видалити ресурс задіяний у події за id
/api/EventResource/eventResource/{id}	PUT	Оновити ресурс задіяний у події за id
/api/EventResource/eventResources	POST	Створити новий задіяний ресурс у події
/api/User/users	GET	Отримати всіх користувачів
/api/User/user/{username}	GET	Отримати користувача за ніком
/api/User/user/{username}	DELETE	Видалити користувача за ніком
/api/User/user/{username}	PUT	Оновити користувача за ніком
/api/Database/backup	POST	Створити бекап бази даних
5.4 Опис частин програмного коду
	5.4.1 Аутентифікація

	Опис частин програмного коду розпочнемо із аутентифікації [5]. Аутентифікація користувачів у застосунку відбувається за допомогою JSON Web Token (додаток А.1).
	Для того, щоб увійти у систему користувач надсилає адресу своєї електронної пошти та пароль. Після цього вони валідуються на сервері із використанням методів ASP.NET Identity:
1	user = await _usersRepository.GetByUsernameAsync(username);
2	var result = _user != null && await _usersRepository.CheckPasswordForUserAsync(_user, password);
	Якщо дані, що ввів користувач співпадають із тими, що знаходяться в базі даних, то у відповідь йому відправляється токен доступу («access token»):
1	var signingCredentials = GetSigningCredentials();
2 	var claims = await GetClaims();
3	var tokenOptions = GenerateTokenOptions(signingCredentials, claims);
4	return new JwtSecurityTokenHandler().WriteToken(tokenOptions);
	Також генерується токен оновлення («refresh token») для користувача, що буде використовуватися для поновлення токену доступу, коли його термін вичерпається. Потім він зберігається у базі даних та відправляється користувачу:
1	var randomNumber = new byte[32];
2	using (var rng = RandomNumberGenerator.Create())
3	{
4		rng.GetBytes(randomNumber);
5		string token = Convert.ToBase64String(randomNumber);
6		return token;
7	}
	Після отримання вищезгаданих токенів користувач отримує повний доступ до системи.
	5.4.2 Обробник помилок 

	Коли у системі виникає помилка, то викликається обробник помилок (додаток А.2). Спочатку за допомогою бібліотеки Serilog логується, де виникла помилка та формується формат відповіді:
1	Logger.Error(contextFeature.Error, "Error during executing {Context}", context.Request.Path.Value);
2	context.Response.ContentType = "application/json";
	Потім обробляємо цю помилку та повертаємо статус помилки для загального розуміння проблеми:
1	Exception exception1 = exception.InnerException ?? exception;
2	var code = exception1 switch
3	{
4		KeyNotFoundException
5			or FileNotFoundException => HttpStatusCode.NotFound,
6   		UnauthorizedAccessException
7			or AuthenticationException => HttpStatusCode.Unauthorized,
8		ArgumentNullException
9			or NullReferenceException
10			or ArgumentException
11			or InvalidOperationException
12			or DbUpdateException
13			or AutoMapperMappingException => HttpStatusCode.BadRequest,
14		_ => HttpStatusCode.InternalServerError,
15	};
16	return code;
	Далі отриманий статус помилки і повідомлення, що прийшло із помилкою повертаються користувачу:
1	await context.Response.WriteAsync(
2		new ExceptionResponse()
3		{
4			StatusCode = (int) status,
5			Message = contextFeature.Error.InnerException == null ? contextFeature.Error.Message : contextFeature.Error.InnerException.Message 
6		}.ToString());
	Цей механізм дозволяє обробити помилки без порушення роботи системи та дає користувачу можливість зрозуміти, причину помилки для подальшого її уникнення.

	5.4.3 Методи розширення

	Для покращення структури коду використовуються методи розширення (додаток А.3). У спеціально відведеному для цього класі відбувається конфігурація JWT, що потім використовується для автентифікації користувачів:
1	options.SaveToken = true;
2	options.RequireHttpsMetadata = false;
3	options.TokenValidationParameters = new TokenValidationParameters
4	{
5	ValidateIssuer = true,
6	ValidateAudience = true,
7	ValidateLifetime = true,
8	ValidateIssuerSigningKey = true,
9	ClockSkew = TimeSpan.Zero,
10	ValidIssuer = jwtConfig["validIssuer"],
11	ValidAudience = jwtConfig["validAudience"],
12	IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secretKey))
13	};
	Також методи розширення використовуються для впровадження залежностей («Dependency Injection») для сервісів:
1	services.AddScoped<IUserService, UserService>();
2	services.AddScoped<IEventService, EventService>();
3	services.AddScoped<IEventResourceService, EventResourceService>();
4	services.AddScoped<ILocationService, LocationService>();
5	services.AddScoped<IMallService, MallService>();
6	services.AddScoped<IResourceService, ResourceService>();
7	services.AddScoped<IRegistrationService, RegistrationService>();
8	services.AddScoped<IReservationService, ReservationService>();
9	services.AddScoped<ITicketService, TicketService>();
10	services.AddScoped<IVenueService, VenueService>();
11	services.AddScoped<IDatabaseService, DatabaseService>();
	Таким чином підтримується чистота коду та спрощується впровадження нового функціоналу для програмної системи.
6 ІОТ ПРИСТРІЙ
6.1 Опис прийнятих інженерних рішень

	Для створення програмного забезпечення для IoT пристрою було використано симулятор Wokwi. Програмний код для пристрою написаний на мові програмування С++. У якості IoT пристрою виступає «розумний» браслет, що надає користувачам доступ до подій та надає можливість відслідковування місцезнаходження його власника (симуляцію зміни яскравості виконує світлодіод). Пристрій складається із мікроконтролера ESP32, 2 кнопок перемикання (зелена та червона), 2 світлодіодів (зелений та червоний), а також сервоприводу (рис. 6.1).

 
Рисунок 6.1 – Будова ІоТ пристрою програмної системи для управління подіями в торгово-розважальних центрах «EventSuite»

	Симуляцію доступу до події виконує натискання зеленої кнопки і за умови надання цього доступу засвітиться зелений світлодіод та спрацює сервопривід, наче турнікет дозволяє пройти на захід, а у разі відхилення доступу засвітиться червоний світлодіод, за це також відповідає червона кнопка. Отримання координат від браслету відбувається шляхом введення даних через наявну у Wokwi консоль, адже там немає ніякої іншої можливості симулювати отримання координат. Таким чином, «розумний» браслет виконує дві функції: надання доступу відвідувачам до подій та відслідковування місцезнаходження його власника.

6.2 Пояснення програмного коду	

Після увімкнення пристрою він під’єднується до WiFi-мережі (додаток Б). Далі створюється вебсервер на 80 порту, який прослуховуватиме HTTP-запити. Для того, аби IoT пристрій міг надсилати запити до серверу створюється HttpClient та за відповідним посиланням відправляється запит на отримання доступу до події:
1	HTTPClient http;
2    http.begin("https://lmpz5drw-5001.euw.devtunnels.ms/api/SmartBracelet/smart-bracelet/1/grant-access");
3    int httpResponseCode = http.GET();
Після отримання відповіді від серверу вона обробляється та власнику «розумного» браслету відображається результат спроби отримання доступу до події. У випадку успішного отримання доступу засвітиться зелений світлодіод та спрацює сервопривід:
1      digitalWrite(LED_GREEN_PIN, HIGH);
2      s1.write(180);
3      delay(3000);
4      digitalWrite(LED_GREEN_PIN, LOW);
5      s1.write(90);
6      delay(3000);
	У іншому випадку засвітиться червоний світлодіод, що сигналізуватиме про відсутність доступу:
1	digitalWrite(LED_RED_PIN, HIGH);
2    delay(1000);
3    digitalWrite(LED_RED_PIN, LOW);
4    delay(1000);
«Розумний» браслет також може отримувати запит на отримання поточних координат для контролю доступу до різних зон події:
1	server.on(UriBraces("/get-coordinates"), HTTP_GET, GetCoordinates);
	Після отримання запиту симуляція зчитування координат відбувається шляхом отримання даних від користувача через консоль та приведення даних до типу «double»: 
1	Serial.print("Enter latitude: ");
2  	while (!Serial.available()) {}
3  
4  	String input = Serial.readStringUntil('\n');
5  	Serial.println(input);
6  
7    data[0] = input.toDouble();
	Далі отримані координати передаються до функції «sendResponse», що відповідає за перетворення даних у формат «json» шляхом їх серіалізації:
1	StaticJsonDocument<2> data;
2  	data["latitude"] = coordinates[0];
3  	data["longitude"] = coordinates[1];
4  	String jsonString;
5
6  	serializeJson(data, jsonString);
	Після цього серіалізовані координати відправяються у відповідь на сервер:
1	server.send(200, "application/json", jsonString);



6.3 Діаграми
	
	Для ІоТ пристрою було створено діаграму прецедентів (рис. 6.2). Для використання пристрою зазначено трьох акторів: відвідувач, організатор та адміністратор. Для відвідувача доступна можливість отримати доступ до події за браслетом, а для організатора та адміністратора можливість управляти «розумними» браслетами та відслідковувати їх місцеположення для контролю доступу до різних зон події.

 
Рисунок 6.2 – Діаграма прецедентів IoT пристрою програмної системи для управління подіями в торгово-розважальних центрах «EventSuite»

	Також було створено діаграму взаємодії (рис. 6.3). Вона надає можливість візуалізувати, як компоненти IoT пристрою взаємодіють між собою в межах системи. Крім того, вона дозволяє зрозуміти логіку застосунку.
 
Рисунок 6.3 – Діаграма взаємодії IoT пристрою програмної системи для управління подіями в торгово-розважальних центрах «EventSuite»

	Діаграма пакетів для ІоТ пристрою містить 6 пакетів (рис. 6.4). «Розумний» браслет є основним пакетом оскільки він складається із 4 інших пакетів: мікроконтролера, світлодіодів, кнопок перемикання та сервоприводу.

 
Рисунок 6.4 – Діаграма пакетів IoT пристрою програмної системи для управління подіями в торгово-розважальних центрах «EventSuite»
	До того ж, було створено діаграму активності (рис. 6.5). Ця діаграма узагальнено показує процес роботи ІоТ пристрою. Вона надає можливість зрозуміти активність, що відбувається в системі.

 
Рисунок 6.5 – Діаграма активності IoT пристрою програмної системи для управління подіями в торгово-розважальних центрах «EventSuite»
	
	Загалом усі наведені діаграми дають краще уявлення про роботу усієї програмної системи для управління подіями в торгово-розважальних центрах «EventSuite».
7 КЛІЄНТСЬКА ЧАСТИНА
7.1 Опис прийнятих інженерних рішень

	Клієнтська частина проекту була розроблена на  мові програмування TypeScript за допомогою фреймворку Angular 16. Створення самого проекту відбувалося у редакторі коду Visual Studio Code. Варто також відзначити, що для авторизації та автентифікації користувачів було використано клас «JwtHelperService» із бібліотеки «auth0/angular-jwt».
	Сам проект знаходиться у папці «app», що містить файли налаштування та 3 інші папки: «api», «core» та «features» (рис. 7.1). Папка «api» містить сервіси, що необхідні для взаємодії із серверною частиною, моделі для відповідних сутностей у системі, а також папку «fn», що містить функції для надсилання запитів на серверну частину. У папці «core» містяться ключові компоненти клієнтського частини програмної системи: домашня сторінка та навігаційна панель. У папці «features» під кожну сутність у базі даних є модулі, що містять відповідні компоненти для їх управління. Також варто відмітити, що налаштування маршрутів клієнтської частини відбувається у файлі «app-routing.module.ts». У файлі «app.module.ts» міститься реєстрація усіх компонентів необхідних для правильного функціонування системи. Крім того, у папці «assets» містяться файли перекладів для локалізації системи у форматі «json».
 
Рисунок 7.1 – Файлова структура клієнтської частини програмної системи для управління подіями в торгово-розважальних центрах «EventSuite» 

	Отримані дані представляються у табличному вигляді із можливістю обрати певну дію для взаємодії (рис. 7.2).

 
Рисунок 7.2 – Представлення даних у клієнтській частині програмної системи для управління подіями в торгово-розважальних центрах «EventSuite»
	Для управління даними (редагування та додавання) були створені сторінки із відповідними формами (рис. 7.3).

 
Рисунок 7.3 – Управління даними у клієнтській частині програмної системи для управління подіями в торгово-розважальних центрах «EventSuite»
	
	Для створення клієнтської частини було використано архітектуру MVVM. Моделі представлені у вигляді інтерфейсів, що відповідають сутностям наявним у програмній системі. Для подання (View) використано HTML-шаблони. А для моделі подання (ViewModel) використано компоненти, що містять методи та функції для взаємодії із відповідними моделями та відображенням їх результату у поданнях.

7.2 Пояснення частин програмного коду
7.2.1 Авторизація 

Після того як користувача було ідентифіковано він отримує токен доступу («access token»), який використовується для отримання захищених ресурсів. Цей токен поміщається в локальне сховище («local storage») і при кожному запиті дістається зі сховища та перевіряється (додаток В.1). Перевірка токену відбувається за допомогою класу «JwtHelperService» із бібліотеки «auth0/angular-jwt».
1  const token = localStorage.getItem("jwt");
2  
3  if (token && !this.jwtHelper.isTokenExpired(token)){
4    return true;
5  }
6  
7  this.router.navigate(["login"]);
8  return false;
	Якщо токен не пройшов перевірку, то користувача перенаправляє на сторінку логіну, де йому треба знову ввести свої дані. У іншому випадку для того, щоб користувача було авторизовано для отримання доступу до захищених ресурсів токен доступу передається у заголовку запиту. Цей процес відбувається автоматично за допомогою «JwtModule» із тієї ж бібліотеки «auth0/angular-jwt» (додаток В.2). Для цього використовується функція «tokenGetter».
1  JwtModule.forRoot({
2    config: {
3      tokenGetter: tokenGetter,
4      allowedDomains: ["localhost:5001"],
5      disallowedRoutes: []
6    }
7  })	
Завдяки цьому механізму відбувається процес авторизації користувачів для отримання доступу до захищених ресурсів.

7.2.2 Локалізація

	У навігаційній панелі в правому її краю міститься розділ для вибору локалізації системи: українська або англійська. При виборі того чи іншого варіанту перекладу сайту викликається функція «onClick()», що поміщає у локальне сховище змінну для обраного перекладу і замінює поточну мову на обрану (додаток В.3).
1 onClick(language: string) {
2    localStorage.setItem('language', language);
3    this.translateService.use(language);
4   }
Також варто відмітити, що при першому вході на сайт при ініціалізації навігаційної панелі відбувається спроба витягнути переклад із локального сховища і за успішної операції він буде застосований. Але у іншому випадку буде обрано переклад за замовчуванням, яким є англійська мова.
1 ngOnInit(): void {
2     var language = localStorage.getItem('language');
3     if (language == null) {
4        localStorage.setItem('language', 'en');
5        this.translateService.use('en');
6     }
7     else {
8        this.translateService.use(language);
9     }
10 }	
Крім того, у файлі «app.module.ts» (додаток В.2) міститься налаштування, що визначає місце розташування файлів для перекладу.
1 export function HttpLoaderFactory(http: HttpClient) {
2  return new TranslateHttpLoader(http, './assets/i18n/', '.json');
3 }
Загалом локалізація клієнтської частини не є складною задачею, але водночас вона є дуже важливою, адже надає користувачам кращий досвід використання програмної системи.




7.3 Діаграми
	
	Для клієнтської частини було створено діаграму прецедентів (рис. 7.4). Вона надає користувачам доступ до функціоналу серверної частини. Ця діаграма також містить 4 актори: власник ТРЦ, організатор подій, відвідувач подій та адміністратор. Слід відмітити, що власник ТРЦ та організатор подій обидва можуть мати доступ до функціоналу відвідувача подій, але в іншому мають доступ тільки до відповідного їх ролям функціоналу.

 
Рисунок 7.4 – Діаграма прецедентів клієнтської частини програмної системи для управління подіями в торгово-розважальних центрах «EventSuite»

	Також було створено діаграму компонентів (рис. 7.5). Вона надає можливість візуалізувати, як компоненти взаємодіють між собою в межах системи. Крім того, ця діаграма є корисною в управлінні модульністю системи та складністю її структури.
 
Рисунок 7.5 – Діаграма компонентів клієнтської частини програмної системи для управління подіями в торгово-розважальних центрах «EventSuite»

	Діаграма пакетів для клієнтської частини містить 2 головних пакети: «Pages» та «Services» (рис. 7.6). Всередині цих пакетів знаходяться інші пакети, що взаємодіють одне з одним.

 
Рисунок 7.6 – Діаграма пакетів клієнтської частини програмної системи для управління подіями в торгово-розважальних центрах «EventSuite»
	До того ж, було створено діаграму станів (рис. 7.7). Ця діаграма показує увесь процес взаємодії користувача із клієнтською частиною. Вона надає можливість зрозуміти які дії необхідно виконати для отримання певного результату.

 
Рисунок 7.7 – Діаграма станів клієнтської частини програмної системи для управління подіями в торгово-розважальних центрах «EventSuite»
	
	Загалом усі наведені діаграми дають краще уявлення про роботу усієї програмної системи для управління подіями в торгово-розважальних центрах «EventSuite».
ВИСНОВКИ

В результаті виконання курсової роботи було досягнуто основної мети – створено програмну систему для управління подіями в торгово-розважальних центрах. Загалом розроблена система надає її користувачам наступні можливості: авторизація та створення нових акаунтів для відвідувачів подій, організаторів подій, власників ТРЦ та адміністраторів; редагування, додавання та видалення даних щодо подій, ресурсів, місць проведення подій, квитків та реєстрації на події, «розумних» браслетів, бронювання місць проведення подій; отримання статистики проведених подій щодо кількості відвідувачів та використаних ресурсів, витрачених коштів та доходу від квитків; створення резервних копій бази даних та управління користувачами і ролями у системі; вибір перекладу інтерфейсу українською або англійською мовами; отримання доступу до подій за «розумними» браслетами; отримання поточного місцезнаходження власника браслету. Ця система автоматизує багато процесів, підвищує точність планування та координації дій, що в свою чергу сприяє покращенню обслуговування відвідувачів і підвищенню прибутковості ТРЦ.
Для створення програмної системи було задіяно чимало технологій, зокрема для розробки серверної частини було використано платформу .NET 8, фреймворк ASP.NET Core 8.0, ORM Entity Framework Core 8.0, систему авторизації та аутентифікації  ASP.NET Core Identity,  а також СУБД Microsoft SQL Server 2019. Клієнтська частини було створена за допомогою фреймворку Angular 16. Для «розумного» браслету (ІоТ пристрій) використовувався мікроконтролер ESP32.
Програмна система має потенціал для подальшого розвитку та вдосконалення, що показало функціональне тестування [6]. Зокрема, можливо розширити функціонал системи за рахунок інтеграції з системами аналітики та прогнозування, розробити мобільні застосунки для організаторів заходів та відвідувачів, а також впровадити технології штучного інтелекту для оптимізації процесів управління.
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ

1. Як організувати подію і не облажатись: покрокова інструкція для майбутніх івент-менеджерів | Kufer. Kufer. URL: https://kufer.media/dumky/yak-organizuvaty-podiyu-i-ne-oblazhatys-pokrokova-instruktsiya-dlya-majbutnih-ivent-menedzheriv/ (дата звернення: 02.06.2024). 
2. Introduction to Identity on ASP.NET Core. Microsoft Learn: Build skills that open doors in your career. URL: https://learn.microsoft.com/en-us/aspnet/core/security/authentication/identity (дата звернення: 02.06.2024).
3. Internet of Things, IoT. IT-Enterprise – your one-stop platform for digital transformation | www.it.ua. URL: https://www.it.ua/knowledge-base/technology-innovation/internet-veschej-internet-of-things-iot (дата звернення: 02.06.2024).
4. Karia R. Entity Framework Core. Entity Framework Tutorial. URL: https://www.entityframeworktutorial.net/efcore/entity-framework-core.aspx (дата звернення: 02.06.2024). 
5. GitHub - NureLukianchukDanylo/apzkr-pzpi-21-3-lukianchuk-danylo. GitHub. URL: https://github.com/NureLukianchukDanylo/apzkr-pzpi-21-3-lukianchuk-danylo (дата звернення: 02.06.2024).
6. Данило Лук`Янчук. 2024 06 03 21 52 29, 2024. YouTube. URL: https://www.youtube.com/watch?v=ZI72_WwnKCA (дата звернення: 05.06.2024).
ДОДАТОК А
Програмний код серверної частини

А.1 Код файлу «UserService.cs»
1 using Microsoft.AspNetCore.Identity;
2 using Microsoft.Extensions.Configuration;
3 using Microsoft.IdentityModel.Tokens;
4 using EventSuite.Core.Models;
5 using EventSuite.DAL.Repositories.Interfaces;
6 using EventSuite.BLL.Services.Interfaces;
7 using System.IdentityModel.Tokens.Jwt;
8 using System.Security.Claims;
9 using System.Security.Cryptography;
10using System.Text;
11
12namespace EventSuite.BLL.Services.Implementations
13{
14    public class UserService : IUserService
15    {
16        private readonly IUserRepository _usersRepository;
17        private readonly IConfiguration _configuration;
18        private User? user;
19
20        public UserService(IUserRepository usersRepository, IConfiguration configuration)
21        {
22            this._usersRepository = usersRepository;
23            this._configuration = configuration;
24        }
25
26        // Method for registering user
27        public async Task<IdentityResult> RegisterUserAsync(User user, string password, string role)
28        {
29            if (user == null)
30                throw new ArgumentException("Invalid arguments");
31            var result = await _usersRepository.CreateUserAsync(user, password);
32            if (!result.Succeeded)
33            {
34                return result;
35            }
36            if (role != null)
37                await _usersRepository.AddRoleToUserAsync(user, role);
38            else
39                await _usersRepository.AddRoleToUserAsync(user, "User");
40            return result;
41        }
42
43        // Method for validating user
44        public async Task<bool> ValidateUserAsync(string username, string password)
45        {
46            user = await _usersRepository.GetByUsernameAsync(username);
47            var result = user != null && await _usersRepository.CheckPasswordForUserAsync(user, password);
48            return result;
49        }
50
51        // Method for generating tokens
52        public async Task<string[]?> GenerateTokensAsync()
53        {
54            var token = await GenerateAccessTokenAsync();
55            var refreshToken = GenerateRefreshTokenAsync();
56            user.RefreshToken = refreshToken;
57            user.RefreshTokenExpiryTime = DateTime.Now.AddDays(Convert.ToDouble(GetConfiguration("refreshTokenExpiresInDays")));
58            await _usersRepository.UpdateUser(user);
59            return [token, refreshToken];
60        }
61
62        // Method for generating access token
63        private async Task<string> GenerateAccessTokenAsync()
64        {
65            var signingCredentials = GetSigningCredentials();
66            var claims = await GetClaims();
67            var tokenOptions = GenerateTokenOptions(signingCredentials, claims);
68            return new JwtSecurityTokenHandler().WriteToken(tokenOptions);
69        }
70
71        // Method for refreshing tokens
72        public async Task<string[]?> RefreshTokensAsync(string accessToken, string refreshToken)
73        {
74            var principal = GetPrincipalFromExpiredToken(accessToken);
75            var username = principal.Identity.Name;
76            user = await _usersRepository.GetByUsernameAsync(username);
77            if (user is null || user.RefreshToken != refreshToken || user.RefreshTokenExpiryTime <= DateTime.Now)
78                return null;
79            var newToken = await GenerateAccessTokenAsync();
80            var newRefreshToken = GenerateRefreshTokenAsync();
81            user.RefreshToken = newRefreshToken;
82            await _usersRepository.UpdateUser(user);
83            return [newToken, newRefreshToken];
84        }
85
86        // Method for revoking token
87        public async Task<IdentityResult> RevokeToken(string username)
88        {
89            user = await _usersRepository.GetByUsernameAsync(username);
90            if (user == null)
91                return null;
92
93            user.RefreshToken = null;
94            user.RefreshTokenExpiryTime = DateTime.MinValue;
95            var res = await _usersRepository.UpdateUser(user);
96            return res;
97        }
98
99        // Method for getting all users
100        public async Task<IEnumerable<User?>> GetUsersAsync()
101        {
102            var users = await _usersRepository.GetAllAsync();
103            return users;
104        }
105
106        // Method for getting user by id
107        public async Task<string> GetRole(User user) 
108        {
109            var role = await _usersRepository.GetRolesForUserAsync(user);
110            return role.FirstOrDefault();
111        }
112
113        private SigningCredentials GetSigningCredentials()
114        {
115            var key = Encoding.UTF8.GetBytes(GetConfiguration("secret"));
116            var secret = new SymmetricSecurityKey(key);
117            return new SigningCredentials(secret, SecurityAlgorithms.HmacSha256);
118        }
119
120        private async Task<List<Claim>> GetClaims()
121        {
122            var claims = new List<Claim>
123            {
124                new Claim(ClaimTypes.Name, user.UserName)
125            };
126            var roles = await _usersRepository.GetRolesForUserAsync(user);
127            foreach (var role in roles)
128            {
129                claims.Add(new Claim(ClaimTypes.Role, role));
130            }
131            return claims;
132        }
133
134        private JwtSecurityToken GenerateTokenOptions(SigningCredentials signingCredentials, List<Claim> claims)
135        {
136            var tokenOptions = new JwtSecurityToken
137            (
138                issuer: GetConfiguration("validIssuer"),
139                audience: GetConfiguration("validAudience"),
140                claims: claims,
141                expires: DateTime.Now.AddMinutes(Convert.ToDouble(GetConfiguration("accessTokenExpiresInMinutes"))),
142                signingCredentials: signingCredentials
143            );
144            return tokenOptions;
145        }
146
147        public string? GetConfiguration(string setting) 
148        {
149            return _configuration.GetSection("JwtConfig")[setting];
150        }
151
152        // Method for generating refresh token
153        private string GenerateRefreshTokenAsync()
154        {
155            var randomNumber = new byte[32];
156            using (var rng = RandomNumberGenerator.Create())
157            {
158                rng.GetBytes(randomNumber);
159                string token = Convert.ToBase64String(randomNumber);
160                return token;
161            }
162        }
163
164        private ClaimsPrincipal GetPrincipalFromExpiredToken(string token)
165        {
166            var tokenValidationParameters = new TokenValidationParameters
167            {
168                ValidateAudience = false,
169                ValidateIssuer = false,
170                ValidateIssuerSigningKey = true,
171                IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(GetConfiguration("secret"))),
172                ValidateLifetime = false
173            };
174            var tokenHandler = new JwtSecurityTokenHandler();
175            SecurityToken securityToken;
176            var principal = tokenHandler.ValidateToken(token, tokenValidationParameters, out securityToken);
177            var jwtSecurityToken = securityToken as JwtSecurityToken;
178            if (jwtSecurityToken == null || !jwtSecurityToken.Header.Alg.Equals(SecurityAlgorithms.HmacSha256, StringComparison.InvariantCultureIgnoreCase))
179                throw new SecurityTokenException("Invalid token");
180            return principal;
181        }
182
183        public async Task<User> GetUserByNameAsync(string userName)
184        {
185            var result = await _usersRepository.GetByUsernameAsync(userName);
186            
187            return result;
188        }
189
190        public async Task<IdentityResult> DeleteUserByNameAsync(string userName)
191        {
192            var user = await _usersRepository.GetByUsernameAsync(userName);
193            if (user == null)
194                return null;
195            return await _usersRepository.DeleteUserAsync(user);
196        }
197
198        public async Task<IdentityResult> UpdateUserAsync(string userName, User user)
199        {
200            if (user == null)
201                throw new ArgumentException("Invalid arguments");
202            var existingUser = await _usersRepository.GetByUsernameAsync(userName);
203            if (existingUser == null)
204                return null;
205            existingUser.FirstName = user.FirstName;
206            existingUser.LastName = user.LastName;
207            existingUser.CompanyName = user.CompanyName;
208            existingUser.Email = user.Email;
209            existingUser.UserName = user.Email;
210            return await _usersRepository.UpdateUser(existingUser);
211        }
212    }
213}
	А.2 Код файлу «ExceptionMiddlewareExtension.cs»
1 using AutoMapper;
2 using Microsoft.AspNetCore.Diagnostics;
3 using Microsoft.EntityFrameworkCore;
4 using Serilog;
5 using EventSuite.Core.DTOs.Responses.Exception;
6 using System.Net;
7 using System.Reflection;
8 using System.Security.Authentication;
9
10namespace EventSuite.API.Extensions
11{
12    public static class ExceptionMiddlewareExtension
13    {
14        private static readonly Serilog.ILogger Logger = Log.ForContext(MethodBase.GetCurrentMethod()?.DeclaringType);
15
16        // Method for configuring exception handler and process exception
17        public static void ConfigureExceptionHandler(this IApplicationBuilder app)
18        {
19            app.UseExceptionHandler(
20                appError =>
21                {
22                    appError.Run(async context =>
23                    {
24                        var contextFeature = context.Features.Get<IExceptionHandlerFeature>();
25
26                        if (contextFeature != null)
27                        {
28                            Logger.Error(contextFeature.Error, "Error during executing {Context}", context.Request.Path.Value);
29                            context.Response.ContentType = "application/json";
30
31                            var status = GetResponse(contextFeature.Error);
32                            await context.Response.WriteAsync(
33                                new ExceptionResponse()
34                                {
35                                    StatusCode = (int)status,
36                                    Message = contextFeature.Error.InnerException == null ? contextFeature.Error.Message : contextFeature.Error.InnerException.Message
37                                }.ToString());
38                        }
39                    });
40                });
41        }
42
43        // Method for getting response status code
44        public static HttpStatusCode GetResponse(Exception exception)
45        {
46            Exception exception1 = exception.InnerException ?? exception;
47            var code = exception1 switch
48            {
49                KeyNotFoundException
50                                    or FileNotFoundException => HttpStatusCode.NotFound,
51                UnauthorizedAccessException
52                                    or AuthenticationException => HttpStatusCode.Unauthorized,
53                ArgumentNullException
54                                    or NullReferenceException
55                                    or ArgumentException
56                                    or InvalidOperationException
57                                    or DbUpdateException
58                                    or AutoMapperMappingException => HttpStatusCode.BadRequest,
59                _ => HttpStatusCode.InternalServerError,
60            };
61            return code;
62        }
63    }
64}
	А.2 Код файлу «ServiceCollectionExtension.cs»
1 using AutoMapper;
2 using Microsoft.AspNetCore.Authentication.JwtBearer;
3 using Microsoft.AspNetCore.Localization;
4 using Microsoft.AspNetCore.Mvc;
5 using Microsoft.IdentityModel.Tokens;
6 using Microsoft.OpenApi.Models;
7 using EventSuite.Core.Mappings;
8 using EventSuite.Core.Models;
9 using EventSuite.DAL.Repositories.Implementations;
10using EventSuite.DAL.Repositories.Interfaces;
11using EventSuite.BLL.Services.Implementations;
12using EventSuite.BLL.Services.Interfaces;
13using System.Globalization;
14using System.Text;
15
16namespace EventSuite.API.Extensions
17{
18    public static class ServiceCollectionExtension
19    {
20        // Method for configuring swagger
21        public static void ConfigureSwagger(this IServiceCollection services)
22        {
23            services.AddSwaggerGen(c =>
24            {
25                c.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme
26                {
27                    Name = "Authorization",
28                    Type = SecuritySchemeType.ApiKey,
29                    Scheme = "Bearer",
30                    BearerFormat = "JWT",
31                    In = ParameterLocation.Header,
32                    Description = "JWT Authorization header using the Bearer scheme."
33                });
34
35                c.AddSecurityRequirement(new OpenApiSecurityRequirement
36                {
37                    {
38                        new OpenApiSecurityScheme
39                        {
40                            Reference = new OpenApiReference
41                            {
42                                Type = ReferenceType.SecurityScheme,
43                                Id = "Bearer"
44                            }
45                        },
46                        new string[] {}
47                    }
48                });
49            });
50        }
51
52        // Method for registering services
53        public static void RegisterServices(this IServiceCollection services)
54        {
55            services.AddScoped<IUserService, UserService>();
56            services.AddScoped<IEventService, EventService>();
57            services.AddScoped<IEventResourceService, EventResourceService>();
58            services.AddScoped<ILocationService, LocationService>();
59            services.AddScoped<IMallService, MallService>();
60            services.AddScoped<IResourceService, ResourceService>();
61            services.AddScoped<IRegistrationService, RegistrationService>();
62            services.AddScoped<IReservationService, ReservationService>();
63            services.AddScoped<ITicketService, TicketService>();
64            services.AddScoped<IVenueService, VenueService>();
65            services.AddScoped<IDatabaseService, DatabaseService>();
66        }
67
68        // Method for registering repositories
69        public static void RegisterRepositories(this IServiceCollection services)
70        {
71            services.AddScoped<IUnitOfWork, UnitOfWork>();
72            services.AddTransient<IGenericRepository<Event>, GenericRepository<Event>>();
73            services.AddTransient<IGenericRepository<Location>, GenericRepository<Location>>();
74            services.AddTransient<IGenericRepository<Mall>, GenericRepository<Mall>>();
75            services.AddTransient<IGenericRepository<Resource>, GenericRepository<Resource>>();
76            services.AddTransient<IGenericRepository<Registration>, GenericRepository<Registration>>();
77            services.AddTransient<IGenericRepository<Ticket>, GenericRepository<Ticket>>();
78            services.AddTransient<IGenericRepository<Venue>, GenericRepository<Venue>>();
79            services.AddTransient<IGenericRepository<EventResource>, GenericRepository<EventResource>>();
80            services.AddTransient<IGenericRepository<Reservation>, GenericRepository<Reservation>>();
81            services.AddScoped<IUserRepository, UserRepository>();
82        }
83
84        // Method for configuring jwt authentication
85        public static void ConfigureJWT(this IServiceCollection services, IConfiguration configuration)
86        {
87            var jwtConfig = configuration.GetSection("jwtConfig");
88            var secretKey = jwtConfig["secret"];
89            services.AddAuthentication(opt =>
90            {
91                opt.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
92                opt.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
93            })
94            .AddJwtBearer(options =>
95            {
96                options.SaveToken = true;
97                options.RequireHttpsMetadata = false;
98                options.TokenValidationParameters = new TokenValidationParameters
99                {
100                    ValidateIssuer = true,
101                    ValidateAudience = true,
102                    ValidateLifetime = true,
103                    ValidateIssuerSigningKey = true,
104                    ClockSkew = TimeSpan.Zero,
105                    ValidIssuer = jwtConfig["validIssuer"],
106                    ValidAudience = jwtConfig["validAudience"],
107                    IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secretKey))
108                };
109            });
110        }
111
112        // Method for configuring mappings
113        public static void ConfigureMapping(this IServiceCollection services)
114        {
115            services.Configure<ApiBehaviorOptions>(options => { options.SuppressModelStateInvalidFilter = true; });
116            var mapperConfig = new MapperConfiguration(map =>
117            {
118                map.AddProfile<UserMappingProfile>();
119                map.AddProfile<LocationMappingProfile>();
120                map.AddProfile<EventMappingProfile>();
121                map.AddProfile<EventResourceMappingProfile>();
122                map.AddProfile<MallMappingProfile>();
123                map.AddProfile<RegistrationMappingProfile>();
124                map.AddProfile<ReservationMappingProfile>();
125                map.AddProfile<ResourceMappingProfile>();
126                map.AddProfile<TicketMappingProfile>();
127                map.AddProfile<VenueMappingProfile>();
128            });
129            services.AddSingleton(mapperConfig.CreateMapper());
130        }
131
132        // Method for configurinf localization
133        public static void ConfigureLocalization(this IServiceCollection services)
134        {
135            services.AddLocalization(x => x.ResourcesPath = "Resources");
136            services.Configure<RequestLocalizationOptions>(
137                options =>
138                {
139                    var supportedCultures = new List<CultureInfo>
140                    {
141                        new CultureInfo("en-US")
142                        {
143                            DateTimeFormat =
144                            {
145                                LongTimePattern = "MM/DD/YYYY",
146                                ShortTimePattern = "MM/DD/YYYY"
147                            }
148                        },
149                        new CultureInfo("uk-UA")
150                        {
151                            DateTimeFormat =
152                            {
153                                LongTimePattern = "DD/MM/YYYY",
154                                ShortTimePattern = "DD/MM/YYYY"
155                            }
156                        }
157                    };
158
159                    options.DefaultRequestCulture = new RequestCulture(culture: "en-US", uiCulture: "en-US");
160                    options.SupportedCultures = supportedCultures;
161                    options.SupportedUICultures = supportedCultures;
162                });
163        }
164    }
165}

ДОДАТОК Б
Програмний код ІоТ пристрою

1 #include <ESP32Servo.h>
2 #include <WiFi.h>
3 #include <WiFiClient.h>
4 #include <WebServer.h>
5 #include <HTTPClient.h>
6 #include <uri/UriBraces.h>
7 #include <ArduinoJson.h>
8
9 #define LED_RED_PIN 4
10#define LED_GREEN_PIN 5
11#define BUTTON_GREEN_PIN 18
12#define BUTTON_RED_PIN 34
13#define SERVO_PIN 12
14#define WIFI_SSID "Wokwi-GUEST"
15#define WIFI_PASSWORD ""
16#define WIFI_CHANNEL 6
17
18WebServer server(80);
19Servo s1;
20
21int lastButtonGreenState = LOW;
22int lastButtonRedState = LOW;
23
24// Send response to server
25void sendResponse(double coordinates[]) {
26  StaticJsonDocument<2> data;
27  data["latitude"] = coordinates[0];
28  data["longitude"] = coordinates[1];
29  String jsonString;
30  //Serialize coordinates
31  serializeJson(data, jsonString);
32  server.send(200, "application/json", jsonString);
33}
34
35void GetCoordinates()
36{
37  double data[2];
38
39  Serial.print("Enter latitude: ");
40  while (!Serial.available()) {
41    // Wait for user input
42  }
43  
44  String input = Serial.readStringUntil('\n');
45  Serial.println(input);
46  
47  try{
48    data[0] = input.toDouble();
49  }
50  catch(double)
51  {
52    Serial.println("Incorrect latitude!");
53  }
54
55  Serial.print("Enter longitude: ");
56  while (!Serial.available()) {
57    // Wait for user input
58  }
59
60  input = Serial.readStringUntil('\n');
61  Serial.println(input);
62
63  try{
64    data[1] = input.toDouble();
65  }
66  catch(double)
67  {
68    Serial.println("Incorrect longitude!");
69  }
70
71  delay(100);
72
73  sendResponse(data);
74}
75
76void setup(void) {
77  Serial.begin(115200);
78
79  pinMode(LED_RED_PIN, OUTPUT);
80  pinMode(LED_GREEN_PIN, OUTPUT);
81  pinMode(BUTTON_GREEN_PIN, INPUT);
82  pinMode(BUTTON_RED_PIN, INPUT);
83  s1.attach(SERVO_PIN);
84
85  // Connect to wifi
86  WiFi.begin(WIFI_SSID, WIFI_PASSWORD, WIFI_CHANNEL);
87  Serial.print("Connecting to WiFi ");
88  Serial.print(WIFI_SSID);
89  
90  while (WiFi.status() != WL_CONNECTED) {
91    delay(100);
92    Serial.print(".");
93  }
94  Serial.println("Connected!");
95
96  // Handle request to get coordinates
97  server.on(UriBraces("/get-coordinates"), HTTP_GET, GetCoordinates);
98  // Start webserver
99  server.begin();
100  
101  Serial.println("HTTP server started");
102}
103
104void loop(void) {
105  server.handleClient();
106  int buttonGreenState = digitalRead(BUTTON_GREEN_PIN);
107  int buttonRedState = digitalRead(BUTTON_RED_PIN);
108  //Wait for button to be pressed
109  if (buttonGreenState != lastButtonGreenState)
110  {
111    HTTPClient http;
112    http.begin("https://lmpz5drw-5001.euw.devtunnels.ms/api/SmartBracelet/smart-bracelet/1/grant-access");
113    //Send request to API
114    int httpResponseCode = http.GET();
115    //Process succesful response
116    if(httpResponseCode > 0)
117    {
118      String response = http.getString();
119      Serial.println(response);
120      digitalWrite(LED_GREEN_PIN, HIGH);
121      s1.write(180);
122      delay(3000);
123      digitalWrite(LED_GREEN_PIN, LOW);
124      s1.write(90);
125      delay(3000);
126    }
127    //Process error
128    else
129    {
130      Serial.print("Error code: ");
131      Serial.println(httpResponseCode);
132      digitalWrite(LED_RED_PIN, HIGH);
133      delay(1000);
134      digitalWrite(LED_RED_PIN, LOW);
135      delay(1000);
136    }
137    lastButtonGreenState = buttonGreenState;
138  }
139  if (buttonRedState != lastButtonRedState)
140  {
141    HTTPClient http;
142    http.begin("https://lmpz5drw-5001.euw.devtunnels.ms/api/SmartBracelet/smart-bracelet/-1/grant-access");
143    //Send request to API
144    int httpResponseCode = http.GET();
145    //Process succesful response
146    if(httpResponseCode > 0)
147    {
148      String payload = http.getString();
149      Serial.println(payload);
150    }
151    //Process error
152    else
153    {
154      Serial.print("Error code: ");
155      Serial.println(httpResponseCode);
156    }
157    digitalWrite(LED_RED_PIN, HIGH);
158    delay(1000);
159    digitalWrite(LED_RED_PIN, LOW);
160    delay(1000);
161    lastButtonRedState = buttonRedState;
162  }
163}
ДОДАТОК В
Програмний код клієнтської частини

В.1 Код файлу «auth-guard.service.ts»
1  import { Injectable } from '@angular/core';
2  import { ActivatedRouteSnapshot, CanActivate, Router, RouterStateSnapshot } from '@angular/router';
3  import { JwtHelperService } from '@auth0/angular-jwt';
4  
5  @Injectable({
6    providedIn: 'root'
7  })
8  export class AuthGuard implements CanActivate  {
9  
10   constructor(private router: Router, private jwtHelper: JwtHelperService){}
11   
12   // Check if user is logged in
13   canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) {
14     const token = localStorage.getItem("jwt");
15 
16     if (token && !this.jwtHelper.isTokenExpired(token)){
17       return true;
18     }
19 
20     this.router.navigate(["login"]);
21     return false;
22   }
23 
24   // Get username from access token
25   getNameFromToken(): string {
26     const token = localStorage.getItem("jwt");
27     if (token) {
28       var username = this.jwtHelper.decodeToken(token)['http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name'];
29       return username;
30     }
31     return "";
32   }
33 }
В.2 Код файлу «app.module.ts»
1 	import { NgModule } from '@angular/core';
2 	import { BrowserModule } from '@angular/platform-browser';
3 	import { TranslateLoader, TranslateModule } from  '@ngx-translate/core';
4 	import { TranslateHttpLoader } from  '@ngx-translate/http-loader';
5
6 	import { AppRoutingModule } from './app-routing.module';
7 	import { AppComponent } from './app.component';
8 	import { HttpClient, HttpClientModule } from '@angular/common/http';
9 	import { FormsModule } from '@angular/forms';
10	import { JwtModule } from '@auth0/angular-jwt';
11	import { HomeComponent } from './core/components/home/home.component';
12	import { NavbarComponent } from './core/components/navbar/navbar.component';
13	import { LoginComponent } from './features/auth/login/login.component';
14	import { RegistrationComponent } from './features/auth/registration/registration.component';
15	import { BackupComponent } from './features/database/backup/backup.component';
16	import { EditUserComponent } from './features/users/edit-user/edit-user.component';
17	import { GetUsersComponent } from './features/users/get-users/get-users.component';
18	import { AddEventComponent } from './features/event/add-event/add-event.component';
19	import { EditEventComponent } from './features/event/edit-event/edit-event.component';
20	import { GetEventsComponent } from './features/event/get-events/get-events.component';
21	import { AddVenueComponent } from './features/venue/add-venue/add-venue.component';
22	import { EditVenueComponent } from './features/venue/edit-venue/edit-venue.component';
23	import { GetVenuesComponent } from './features/venue/get-venues/get-venues.component';
24	import { AddResourceComponent } from './features/resource/add-resource/add-resource.component';
25	import { EditResourceComponent } from './features/resource/edit-resource/edit-resource.component';
26	import { GetResourcesComponent } from './features/resource/get-resources/get-resources.component';
27	import { AddLocationComponent } from './features/location/add-location/add-location.component';
28	import { EditLocationComponent } from './features/location/edit-location/edit-location.component';
29	import { GetLocationsComponent } from './features/location/get-locations/get-locations.component';
30	import { AddMallComponent } from './features/mall/add-mall/add-mall.component';
31	import { EditMallComponent } from './features/mall/edit-mall/edit-mall.component';
32	import { GetMallsComponent } from './features/mall/get-malls/get-malls.component';
33	import { GetFinishedEventsComponent } from './features/event/get-finished-events/get-finished-events.component';
34	import { AddRegistrationComponent } from './features/registration/add-registration/add-registration.component';
35	import { EditRegistrationComponent } from './features/registration/edit-registration/edit-registration.component';
36	import { GetRegistrationsComponent } from './features/registration/get-registrations/get-registrations.component';
37	import { AddTicketComponent } from './features/ticket/add-ticket/add-ticket.component';
38	import { EditTicketComponent } from './features/ticket/edit-ticket/edit-ticket.component';
39	import { GetTicketsComponent } from './features/ticket/get-tickets/get-tickets.component';
40	import { GetSmartBraceletsComponent } from './features/smart-bracelet/get-smart-bracelets/get-smart-bracelets.component';
41	import { AddSmartBraceletComponent } from './features/smart-bracelet/add-smart-bracelet/add-smart-bracelet.component';
42	import { EditSmartBraceletComponent } from './features/smart-bracelet/edit-smart-bracelet/edit-smart-bracelet.component';
43	import { AddReservationComponent } from './features/reservation/add-reservation/add-reservation.component';
44	import { EditReservationComponent } from './features/reservation/edit-reservation/edit-reservation.component';
45	import { GetReservationsComponent } from './features/reservation/get-reservations/get-reservations.component';
46	import { AddEventResourceComponent } from './features/event-resource/add-event-resource/add-event-resource.component';
47	import { EditEventResourceComponent } from './features/event-resource/edit-event-resource/edit-event-resource.component';
48	import { GetEventResourcesComponent } from './features/event-resource/get-event-resources/get-event-resources.component';
49
50	export function tokenGetter() { 
51  		return localStorage.getItem("jwt"); 
52	}
53
54	export function HttpLoaderFactory(http: HttpClient) {
55  		return new TranslateHttpLoader(http, './assets/i18n/', '.json');
56	}
57
58	@NgModule({
59  		declarations: [
60    		AppComponent,
61    		HomeComponent,
62    		NavbarComponent,
63    		LoginComponent,
64    		RegistrationComponent,
65    		BackupComponent,
66    		EditUserComponent,
67    		GetUsersComponent,
68    		AddEventComponent,
69    		EditEventComponent,
70    		GetEventsComponent,
71    		AddVenueComponent,
72    		EditVenueComponent,
73    		GetVenuesComponent,
74    		AddResourceComponent,
75    		EditResourceComponent,
76    		GetResourcesComponent,
77    		AddLocationComponent,
78    		EditLocationComponent,
79    		GetLocationsComponent,
80    		AddMallComponent,
81    		EditMallComponent,
82    		GetMallsComponent,
83    		GetFinishedEventsComponent,
84    		AddRegistrationComponent,
85    		EditRegistrationComponent,
86    		GetRegistrationsComponent,
87    		AddTicketComponent,
88    		EditTicketComponent,
89    		GetTicketsComponent,
90    		GetSmartBraceletsComponent,
91    		AddSmartBraceletComponent,
92    		EditSmartBraceletComponent,
93    		AddReservationComponent,
94    		EditReservationComponent,
95    		GetReservationsComponent,
96    		AddEventResourceComponent,
97    		EditEventResourceComponent,
98    		GetEventResourcesComponent
99  		],
100  	imports: [
101    		BrowserModule,
102    		AppRoutingModule,
103    		HttpClientModule,
104    		FormsModule,
105    		TranslateModule.forRoot({
106      			defaultLanguage: 'en',
107      				loader: {
108        				provide: TranslateLoader,
109        				useFactory: HttpLoaderFactory,
110        				deps: [HttpClient],
111      				}
112    			}),
113    		JwtModule.forRoot({
114      			config: {
115        			tokenGetter: tokenGetter,
116        			allowedDomains: ["localhost:5001"],
117        			disallowedRoutes: []
118      			}
119    		}),
120  	],
121  	providers: [],
122  	bootstrap: [AppComponent]
123	})
124	export class AppModule { }
В.3 Код файлу «navbar.component.ts»
1  import { Component } from '@angular/core';
2  import { JwtHelperService } from '@auth0/angular-jwt';
3  import {TranslateService} from "@ngx-translate/core";
4  import { AuthGuardService } from 'src/app/features/auth/services/auth-guard.service';
5
6  @Component({
7   selector: 'app-navbar',
8   templateUrl: './navbar.component.html',
9   styleUrls: ['./navbar.component.css']
10 })
11 export class NavbarComponent {
12  constructor(private jwtHelper: JwtHelperService, private translateService: TranslateService) { }
13
14  ngOnInit(): void {
15    var language = localStorage.getItem('language');
16    if (language == null) {
17      localStorage.setItem('language', 'en');
18      this.translateService.use('en');
19    }
20    else {
21      this.translateService.use(language);
22    }
23  }
24
25  isUserAuthenticated = (): boolean => {
26    const token = localStorage.getItem("jwt");
27
28    if (token && !this.jwtHelper.isTokenExpired(token)){
29    return true;
30    }
31
32    return false;
33  }
34  
35  	logOut = () => {
36    	localStorage.removeItem("jwt");
37  	}
38
39  	onClick(language: string) {
40    	localStorage.setItem('language', language);
41    	this.translateService.use(language);
42  	}
43 }
ДОДАТОК Г
Результат перевірки на плагіат

 
Рисунок Г.1 – Результат перевірки на плагіат
